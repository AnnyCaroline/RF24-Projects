#include "out.ceu"
#include "pcint1.ceu"
#include "usart.ceu"
#include "string.ceu"
#include "int0.ceu"
#include "spi.ceu"

#define NRF24L01_IRQ INT0
#include "nrf24l01.ceu"

output high/low OUT_04;
call PCINT1_Enable(_PCINT8, on); // UNO=A0, MEGA=D0
emit OUT_04(low);

var Lock spi = _;
var NRF24L01_Data nrf = val NRF24L01_Data(&spi, 8, 7, _,_,_,_,_,_,_);
spawn NRF24L01_Init(&nrf);
await nrf.ok;

var int timeout = 300; //ms

spawn USART_Init(9600);

// var[5] byte str = [].."tx\r\n";
// await USART_Tx(&str);

var u8 seq = 0<<6;

var[3] byte bufUsart;

loop do
    await PCINT1;

    // if the interruption was generated by the btn connected to PCINT8
    if (call PCINT1_Get(_PCINT8) == high) then

        emit OUT_04(high);

        loop do
            par/or do
                // timeout for retransmission
                //await (timeout)ms;
                await FOREVER;
            with
                // Print seq number that will be send
                /////////////////////////////////////
                var[3] byte bufUsart1;
                if (seq == 1<<6) then
                    call String_Append_STR(&bufUsart1, ">1");
                else
                    call String_Append_STR(&bufUsart1, ">0");
                end
                await USART_Tx(&bufUsart1);
                
                var[1] byte bufTx = [seq];
                await NRF24L01_Tx(&nrf, &bufTx);
                     
                var[1] byte bufRx;
                await NRF24L01_Rx(&nrf, &bufRx);

                var[20] byte bufrecebi;
                call String_Append_INT(&bufrecebi, bufRx[0], _);
                await USART_Tx(&bufrecebi);

                    
                // verifico se é um ACK
                if (bufRx[0] & (1<<7) == (1<<7)) then
                    // verifico se é do número de sequencia que eu quero
                    if (bufRx[0] & (1<<6) == seq) then
                        // troco o seq
                        if (seq == (0<<7)) then
                            seq = (1<<6);
                        else
                            seq = (0<<6);
                        end

                        break;
                    end
                    // se não for o SEQ que eu quero, é duplicado.
                    // ACKs duplicados resultam em retransmissão do pacote atual
                    // Essa retransmissão ocorrerá pelo timeout (bloco em paralelo acima)

                    // Print received buffer
                    /////////////////////////
                    var[20] byte bufAqui;
                    call String_Append_STR(&bufAqui, "aqui\n");
                    await USART_Tx(&bufAqui);
                end
                // se não for um ACK, ignoro
            end
        end

        emit OUT_04(low);
    end

    await 100ms; //debounce
end